snippet Yd "YAML.dump()"
YAML.dump(${1})
endsnippet
snippet Yl "YAML.load()"
YAML.load(${1})
endsnippet
snippet am "am"
alias_method :${1:new_name}, :${2:old_name}
endsnippet
snippet api "api"
#
# API
#

endsnippet
snippet clb "callbacks"
#
# Callbacks
#

endsnippet
snippet as "as"
assert ${1:test}, "${2:failure_message}"
endsnippet
snippet ase "ase"
assert_equal ${1:expected}, ${2:actual}
endsnippet
snippet asid "asid"
assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:delta_float}
endsnippet
snippet asio "asio"
assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}
endsnippet
snippet asko "asko"
assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}
endsnippet
snippet asm "asm"
assert_match /${1:expected_pattern}/, ${2:actual_string}
endsnippet
snippet asn "asn"
assert_nil ${1:instance}
endsnippet
snippet asne "asne"
assert_not_equal ${1:unexpected}, ${2:actual}
endsnippet
snippet asnm "asnm"
assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}
endsnippet
snippet asnn "asnn"
assert_not_nil ${1:instance}
endsnippet
snippet asns "asns"
assert_not_same ${1:unexpected}, ${2:actual}
endsnippet
snippet asnt "asnt"
assert_nothing_thrown { ${1} }
endsnippet
snippet aso "aso"
assert_operator ${1:left}, :${2:operator}, ${3:right}
endsnippet
snippet asr "asr"
assert_raise(${1:Exception}) { ${2} }
endsnippet
snippet asrt "asrt"
assert_respond_to ${1:object}, :${2:method}
endsnippet
snippet ast "ast"
assert_throws(:${1:expected}) { ${2} }
endsnippet
snippet atr "atr"
#
# Attributes
#

endsnippet
snippet bhv "bhv"
#
# Behaviors
#

endsnippet
snippet bm "bm"
amount = 1000
Benchmark.bmbm do |x|
  x.report do
    amount.times do
      ${1} 
    end
  end
  x.report do
    amount.times do
  	  ${2}
    end
  end
end
endsnippet
snippet case "case"
case ${1}
when ${2}
else
	${3}
end
endsnippet
snippet class "class"
class ${1:`!v Snippet_RubyClassNameFromFilename()`}
  $2
end
endsnippet
snippet classe "classe"
class ${1:`!v Snippet_RubyClassNameFromFilename()`} < ${2:}
end
endsnippet
snippet clm "srv"
#
# Services
#

endsnippet
snippet df "df"
def ${1:name}
	${2}
end

endsnippet
snippet dfa "dfa"
def ${1:}
  raise NotImplementedError, "#{self.class}##{__method__} suppose to be overwritten"
end
endsnippet
snippet dfi "dfi"
def initialize${1}
end
endsnippet
snippet dfmm "dfmm"
def method_missing(meth, *args, &blk)
	${1}
end
endsnippet
snippet dfs "dfs"
def self.${1:class_method_name}
end
endsnippet
snippet dft "dft"
def test_${1:case_name}
	${2}
end
endsnippet
snippet dop "dop"
do |${1:param}|
	${2}
end
endsnippet
snippet dp "dp"
do |${1}|
endsnippet
snippet ea "ea"
each { |${1:element}| ${2:body} }
endsnippet
snippet each "each"
each do |${1:element}|
	${2:body}
end
endsnippet
snippet eado "eado"
each do |${1:element}|
	${2:body}
end
endsnippet
snippet eawi "eawi"
each_with_index do |${1:element},${2:i}|
	${3:body}
end
endsnippet
snippet fopen "fop"
File.open(${1:path}, "${2:w}") do |${3:file}| 
  ${4} 
end
endsnippet
snippet fread "frd"
File.read(${1})
endsnippet
snippet i18 "i18"
I18n.t('${1:type.key}')${2}
endsnippet
snippet imp "imp"
#
# Implementation
#

endsnippet
snippet inj "inj"
inject(${1:init}) do |${2:total}, ${3:next}|
	${4:body}
end
endsnippet
snippet job "job"
class ${1:`!v Snippet_RubyClassNameFromFilename()`}${2}

  @queue = :${3:low}

  def self.perform${4}

end
endsnippet
snippet k "k" i
${1:}: $1${2:}
endsnippet
snippet la "la"
lambda { |${1:id}| ${2}}
endsnippet
snippet map "map"
map { |${1:element}| ${2:body} }
endsnippet
snippet mapdo "mapdo"
map do |${1:element}|
	${2:body}
end
endsnippet
snippet mapo "mapo"
map do |${1:element}|
	${2:body}
end
endsnippet
snippet mod "mod"
module ${1:`!v Snippet_RubyClassNameFromFilename()`}
	${2}
end
endsnippet
snippet module "module"
module ${1:`!v Snippet_RubyClassNameFromFilename()`}

	def self.included(base)
		base.extend         ClassMethods
		base.class_eval do
		  ${2}
		end
	end # self.included

	module ClassMethods

	end # ClassMethods

end
endsnippet
snippet mp "mp"
map(&:${1:id})
endsnippet
snippet mrw "mrw"
mattr_accessor :${1:attr_names}
endsnippet
snippet nam "nam"
namespace :${1:namespace} do
	${2}
end
endsnippet
snippet ope "ope"
open(${1:path}, "${2:rwab}") { |${3:io}| ${4} }
endsnippet
snippet pathhere "pathhere"
File.join(File.dirname(__FILE__), *%w[${1:rel_path_here}])
endsnippet
snippet r "r"
attr_reader :${1:attr_names}
endsnippet
snippet rejecto "rejecto"
reject do |${1:element}|
	${2:body}
end
endsnippet
snippet req "req"
require "${1}"
endsnippet
snippet rw "rw"
attr_accessor :${1:attr_names}
endsnippet
snippet s "s"
self.$0
endsnippet
snippet select "select"
select { |${1:element}| ${2:body} }
endsnippet
snippet selecto "selecto"
select do |${1:element}|
	${2:body}
end
endsnippet
snippet sha1 "sha1"
Digest::SHA1.hexdigest(${1:string})
endsnippet
snippet sinc "sinc"
class << self; self end
endsnippet
snippet sort "sort" w
sort do |${1:x},${2:y}|
	${3:body}
end
endsnippet
snippet w "w"
attr_writer :${1:attr_names}
endsnippet
snippet dbg "debugger" w
require 'debugger'
debugger
endsnippet
snippet bb "byebug" w
require 'byebug'; byebug
endsnippet

snippet pa "params[:id]" w
params[:${1:id}]
endsnippet

snippet anaf "accepts_nested_attributes_for"
accepts_nested_attributes_for :${1:association_name}${2:${3:, allow_destroy: true}${4:, reject_if: proc \{ |obj| ${5:obj.blank?} \}}}
endsnippet
snippet asc "asc"
#
# Associations
#

endsnippet
snippet ba "before_action"
before_filter :${1:method}
endsnippet
snippet bam "before_action with method"
before_filter :${1:method}

def ${1/(\w+).*/$1/}
  ${3}
end
endsnippet
snippet bt "bt"
belongs_to :${1:association}
endsnippet
snippet defcreate "defcreate"
def create
	@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])

	if @$1.save
		flash[:notice] = '$2 was successfully created.'
		redirect_to(@$1) 
	else
		render action: "new" 
	end
end
endsnippet
snippet defdestroy "defdestroy"
def destroy
	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	@$1.destroy

	redirect_to($1s_url) 
end${3}
endsnippet
snippet defedit "defedit"
def edit
end
endsnippet
snippet defindex "defindex"
def index
	@${1:model_class_name} = ${2:ModelClassName}.all
end${3}
endsnippet
snippet defnew "defnew"
def new
	@${1:model_class_name} = ${2:ModelClassName}.new
end${3}
endsnippet
snippet defshow "defshow"
def show
end
endsnippet
snippet defupdate "defupdate"
def update
  if @${1:model_instance_name}.update_attributes(params[:$1])
  	flash[:notice] = '${2} was successfully updated.'
  	redirect_to(@$1) 
  else
  	render action: :edit 
  end
end
endsnippet
snippet dso "dso"
default_scope order: "${1:created_at desc}"
endsnippet
snippet fl "fl"
flash[:${1:notice}] = "${2}"
endsnippet
snippet fpid "fpid"
find(params[:${1}id])
endsnippet
snippet habtm "habtm"
has_and_belongs_to_many :${1:object}, join_table: "${2:table_name}", foreign_key: "${3}_id"${4}
endsnippet
snippet hm "hm"
has_many :${1}, dependent: :destroy$0
endsnippet
snippet hmt "hmt"
has_many :${1:object}, through: :${2:object}
endsnippet
snippet ho "ho"
has_one :${1:object}, dependent: :destroy$0
endsnippet
snippet mac "mac"
add_column :${1:table}, :${2:column}, :${3:string}
endsnippet
snippet mai "mai"
add_index :${1:table}, [:${2:column}]${3:, unique: true}
endsnippet
snippet mbs "mbs"
before_save :${1:method}
endsnippet
snippet mcc "mcc"
change_column :${1:table}, :${2:column}, :${3:type}
endsnippet
snippet mccc "mccc"
t.column :${1:title}, :${2:string}
endsnippet
snippet mcht "mcht"
change_table :${1:table_name} do |t|
	${2}
end
endsnippet
snippet mcol "mcol"
remove_column :${1:table}, :${2:column}
endsnippet
snippet mct "mct"
create_table :${1} do |t|
	t.${2:integer} :${3}
end
endsnippet
snippet mctmm "mctmm"
create_table :${1:}, id: false do |t|
	t.integer :${2:}_id, null: false
	t.integer :${3:}_id, null: false
end


add_index :$1, :$2_id
add_index :$1, [:$3_id, :$2_id], unique: true

add_foreign_key :$1, :$2_id, references: :$2s, on_delete: :cascade
add_foreign_key :$1, :$3_id, references: :$3s, on_delete: :cascade
endsnippet
snippet mfk "mfk"
add_index :${1:}, :${2:}_id
add_foreign_key :$1, :$2_id, references: :${3:$2}s, on_delete: :${4:restrict}

endsnippet
snippet migration "migration"
class ${1:`!v Snippet_MigrationNameFromFilename()`} < ActiveRecord::Migration
	def self.up
		${2}
	end

	def self.down
	end
end
endsnippet
snippet pid "pid"
params[:${1}id]
endsnippet
snippet rest "rest"
respond_to do |f|
	f.html { ${1} }
	f.json do
		render json: {${2}}
	end
end
endsnippet
snippet rjson "rjson"
render json: {${1:}}
endsnippet
snippet rp "rp"
render partial: "${1:item}"$0
endsnippet
snippet rpl "rpl"
render partial: "${1:}", locals: { ${2:} }
endsnippet
snippet rpo "rpo"
render partial: "${1}", object: ${2}
endsnippet
snippet rt "rt"
render text: "${1:text to render}"
endsnippet
snippet rts "rts"
render_to_string partial: "${1}"
endsnippet
snippet sc "sc"
scope :${1}, ${2:where()}
endsnippet
snippet scp "scp"
scope :${1}, ->(${2}) {
  where(${3})
}
endsnippet
snippet scs "scs"
#
# Scopes
#

endsnippet
snippet tcb "tcb"
t.boolean :${1:truthly}
endsnippet
snippet tcd "tcd"
t.decimal :${1:value}, precision: ${2:2}, scale: ${3:10}
endsnippet
snippet tcda "tcda"
t.date :${1:date}
endsnippet
snippet tcdt "tcdt"
t.datetime :${1:title}
endsnippet
snippet tcf "tcf"
t.float :${1:value}
endsnippet
snippet tch "tch"
t.change :${1}, :${2:string}
endsnippet
snippet tci "tci"
t.integer :${1:id}
endsnippet
snippet tcs "tcs"
t.string :${1:title}
endsnippet
snippet tct "tct"
t.text :${1:body}
endsnippet
snippet tcti "tcti"
t.time :${1:title}
${2}
endsnippet
snippet tcts "tcts"
t.timestamp :${1:title}
${2}
endsnippet
snippet tctss "tctss"
t.timestamps
${1}
endsnippet
snippet trc "trc"
t.remove :${1:column}
endsnippet
snippet tre "tre"
t.rename :${1}, :${2}
endsnippet
snippet tref "tref"
t.references :${1:model}
endsnippet
snippet va "va"
validates_associated :${1:attribute}
endsnippet
snippet vao "vao"
validates_acceptance_of :${1:terms}
endsnippet
snippet vco "vco"
validates_confirmation_of :${1:attribute}
endsnippet
snippet veo "veo"
validates_exclusion_of :${1:attribute}, in: ${2:%w( mov avi )}
endsnippet
snippet vfo "vfo"
validates_format_of :${1:attribute}, with: /${2:regex}/
endsnippet
snippet vio "vio"
validates_inclusion_of :${1:attribute}, in: ${2}
endsnippet
snippet vlo "vlo"
validates_length_of :${1:attribute}, within: ${2:3}..${3:20}
endsnippet
snippet vld "vld"
#
# Validation
#

endsnippet
snippet vn "vno"
validates_numericality_of :${1:attribute}
endsnippet
snippet vpo "vpo"
validates_presence_of :${1:attribute}
endsnippet
snippet vuo "vuo"
validates_uniqueness_of :${1:attribute}${2:, scope: [:${3}]}
endsnippet
snippet mrmc "mrmc"
remove_column :${1:table}, :${2:column}
endsnippet
snippet mrnc "mrnc"
rename_column :${1:table}, :${2:old}, :${3:new}
endsnippet
snippet aft "aft"
after(${1::each}) do
	${2}
end
endsnippet
snippet anr "anr"
and_return(${1:value})
endsnippet
snippet anra "anra"
and_raise(${1:exception})
endsnippet
snippet anrb "anrb"
and_return { ${1} }
endsnippet
snippet ant "ant"
and_throw(${1:sym})
endsnippet
snippet any "any"
and_yield(${1:values})
endsnippet
snippet avf "avf"
it {should accept_values_for(:${1:}, ${2})}
it {should_not accept_values_for(:$1, ${3:nil})}
endsnippet
snippet avfn "avfn"
it {should_not accept_values_for(:${1}, ${2:nil})}
endsnippet
snippet bef "bef"
before do
	${1}
end
endsnippet
snippet befa "befa"
before(:all) do
	${1}
end
endsnippet
snippet des "des"
describe "${1}" do
	${2}
end
endsnippet
snippet desa "desa"
describe "${1:get} ${2:show}" do
  subject { $1 :${3:$2} }

  it { should be_${4:success} }

end
endsnippet
snippet desc "desc"
require 'spec_helper'

describe ${1:`!v Snippet_RubySpecNameFromFilename()`} do
	${2}
end
endsnippet
snippet desm "desm"
require 'spec_helper'

describe ${1:`!v Snippet_RubySpecNameFromFilename()`} do
  
	subject { build(:${2:`!v Snippet_RubyFactoryNameFromFilename()`}) }

	it {should be_valid}

end
endsnippet
snippet desns "desns"
describe ".${1:}" do

  subject { described_class.$1${2} }

	it { should include(${3})}

	it { should_not include(${4})}


end
endsnippet
snippet dess "dess"
describe "${1:name}" do
	${2}
end
endsnippet
snippet dest "dest"
describe ${1:Type} do
	${2}
end
endsnippet
snippet atl "atl"
at_least(${1:n}).times
endsnippet
snippet atm "atm"
at_most(${1:n}).times
endsnippet
snippet con "con"
context "${1}" do
  ${2}
end
endsnippet
snippet cona "cona"
context "after #${1:save!}" do
  before(:each) do
    subject.$1
	end
	${2}
end
endsnippet
snippet fc "fc"
create(:${1:`!v Snippet_RubyFactoryNameFromFilename()`}, ${2})
endsnippet
snippet fca "fca"
association :${1}
endsnippet
snippet fcat "fcat"
attributes_for(:${1:`!v Snippet_RubyFactoryNameFromFilename()`})
endsnippet
snippet fcb "fcb"
build(:${1:`!v Snippet_RubyFactoryNameFromFilename()`})
endsnippet
snippet fcc "fcc"
create(:${1:`!v Snippet_RubyFactoryNameFromFilename()`})
endsnippet
snippet fcd "fcd"
FactoryBot.define do
  factory :${1} do
    ${2}
  end
end
endsnippet
snippet fcn "fcn"
FactoryBot.next(:${1:sequence-name})
endsnippet
snippet fcs "fcs"
f.sequence(:${1}) {|n| "${2}#{n}"}
endsnippet
snippet is "is"
it { should ${1} }
endsnippet
snippet isbl "isbl"
it_should_behave_like '${1}'
endsnippet
snippet isn "isn"
it { should_not ${1} }
endsnippet
snippet it "it"
it "${1}" do
	${2}
end
endsnippet
snippet its "its"
it "should ${1:work correctly}" do
  ${2}
end
endsnippet
snippet let "let"
let(:${1}) { ${2} }
endsnippet
snippet letf "letf"
let(:${1:model}) do 
  create(:${2:$1${3}})
end
endsnippet
snippet mat "mat"
class ${1:ReverseTo}
	def initialize(${2:param})
		@$2 = $2
	end

	def matches?(actual)
		@actual = actual
		# Satisfy expectation here. Return false or raise an error if it's not met.
		${3:@actual.reverse.should == @$2}
		true
	end

	def failure_message
		"expected #{@actual.inspect} to ${4} #{@$2.inspect}, but it didn't"
	end

	def negative_failure_message
		"expected #{@actual.inspect} not to ${5} #{@$2.inspect}, but it did"
	end
end

def ${6:reverse_to}(${7:expected})
	${8}.new($7)
end
endsnippet
snippet seg "seg"
shared_examples_for "${1:}" do
  ${2}
end
endsnippet
snippet sh "sh"
${1:target}.should == ${2:value}
${3}
endsnippet
snippet shb "shb"
${1:target}.should be(${2:result})
${3}
endsnippet
snippet shbc "shbc"
${1:target}.should be_close(${2:result}, ${3:tolerance})
${4}
endsnippet
snippet shbio "shbio"
${1:target}.should be_instance_of(${2:class})
${3}
endsnippet
snippet shbko "shbko"
${1:target}.should be_a_kind_of(${2:class})
${3}
endsnippet
snippet shbr "shbr"
response.should be_redirect
${1}
endsnippet
snippet shbs "shbs"
response.should be_success
${1}
endsnippet
snippet exc "exc"
expect(->{
	${1}
}).to change(${2:described_class}, :${3:count}).by(${4:1})
endsnippet
snippet exr "exr"
expect(->{
	${1}
}).to raise_error(${2:StandardError})
endsnippet
snippet shdm "shdm"
${1:target}.should match(/${2:regexp}/)
${3}
endsnippet
snippet she "she"
${1:target}.should eql(${2:value})
${3}
endsnippet
snippet sheq "sheq"
${1:target}.should equal(${2:value})
${3}
endsnippet
snippet shh "shh"
${1:target}.should have(${2:num}).${3:things}
${4}
endsnippet
snippet shhal "shhal"
${1:target}.should have_at_least(${2:num}).${3:things}
${4}
endsnippet
snippet shham "shham"
${1:target}.should have_at_most(${2:num}).${3:things}
${4}
endsnippet
snippet shhr "shhr"
${1:target}.should have(${2:n}).records
${3}
endsnippet
snippet shn "shn"
${1:target}.should_not == ${2:value}
${3}
endsnippet
snippet shnb "shnb"
${1:target}.should_not be(${2:result})
${3}
endsnippet
snippet shnbc "shnbc"
${1:target}.should_not be_close(${2:result}, ${3:tolerance})
${4}
endsnippet
snippet shnbio "shnbio"
${1:target}.should_not be_instance_of(${2:klass})
${3}
endsnippet
snippet shnbko "shnbko"
${1:target}.should_not be_a_kind_of(${2:klass})
${3}
endsnippet
snippet shnbr "shnbr"
response.should_not be_redirect
${1}
endsnippet
snippet shnbs "shnbs"
response.should_not be_success
${1}
endsnippet
snippet shnc "shnc"
lambda do
	${1}
end.should_not change(${2:target}, :${3:method})
endsnippet
snippet shne "shne"
${1:target}.should_not eql(${2:value})
${3}
endsnippet
snippet shneq "shneq"
	${1:target}.should_not equal(${2:value})
	${3}
endsnippet
snippet shnm "shnm"
${1:target}.should_not match(/${2:regexp}/)
${3}
endsnippet
snippet shnp "shnp"
${1:target}.should_not be_${2:predicate}
endsnippet
snippet shnr "shnr"
${1:mock}.should_not_receive(:${2:message})${3}
${4}
endsnippet
snippet shnre "shnre"
${1:target}.should_not raise_error(${2:error})
${3}
endsnippet
snippet shnredt "shnredt"
response.should_not redirect_to(${1:url})
${2}
endsnippet
snippet shnrt "shnrt"
${1:target}.should_not respond_to(:${2:sym})
${3}
endsnippet
snippet shp "shp"
${1:target}.should be_${2:predicate}
endsnippet
snippet shr "shr"
${1:mock}.should_receive(:${2:message})${3}
${4}
endsnippet
snippet shre "shre"
${1:target}.should raise_error(${2:error})
${3}
endsnippet
snippet shredt "shredt"
response.should redirect_to(${1:url})
${2}
endsnippet
snippet shrt "shrt"
${1:target}.should respond_to(:${2:sym})
${3}
endsnippet
snippet st "st"
stubs(:${1}).returns(${2})
endsnippet
snippet subj "subj"
subject { ${1:build(${2:described_class.to_s.underscore})} }
endsnippet

snippet ff "focused: true" w
, focused: true
endsnippet
snippet task "task"
desc "${1:Task description}"
task :${2:task_name}${3: => ["${4:dependent}"]} do
	${5}
end
endsnippet

snippet trb "find_in_batches transaction" i
find_in_batches do |batch|
	ActiveRecord::Base.transaction do
		batch.each do |${1}|
			${2}
		end
	end
end
endsnippet

snippet lhm "Lhm.change_table" !b
Lhm.change_table :${1}, stride: 10_000 do |t|
	t.${2:add_column}
end
endsnippet
snippet	ex "expect() to eq()"
expect($1).to ${2:eq($3)}
endsnippet
snippet	exn "expect() to_not eq()"
expect($1).to_not ${2:eq($3)}
endsnippet
snippet bp "binding.pry" w
require 'pry-byebug';binding.pry
endsnippet
snippet	fsl "frozen_string_literal"
# frozen_string_literal: true
endsnippet
